"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
const constants_1 = require("../../constants");
const utils_1 = require("../../utils");
function parse(chars, state, tokens) {
    if (chars === '"' || chars === "'") {
        return parseWrapper(state, tokens);
    }
    if (chars === ">" || chars === "/") {
        return parseTagEnd(state);
    }
    if (!(0, utils_1.isWhitespace)(chars)) {
        return parseBare(state);
    }
    state.decisionBuffer = "";
    state.caretPosition++;
}
exports.parse = parse;
function parseWrapper(state, tokens) {
    const wrapper = state.decisionBuffer;
    const range = [state.caretPosition, state.caretPosition + 1];
    const loc = (0, utils_1.calculateTokenLocation)(state.source, range);
    tokens.push({
        type: constants_1.TokenTypes.AttributeValueWrapperStart,
        value: wrapper,
        range,
        loc,
    });
    state.accumulatedContent = "";
    state.decisionBuffer = "";
    state.currentContext = constants_1.TokenizerContextTypes.AttributeValueWrapped;
    state.contextParams[constants_1.TokenizerContextTypes.AttributeValueWrapped] = {
        wrapper,
    };
    state.caretPosition++;
}
function parseBare(state) {
    state.accumulatedContent = state.decisionBuffer;
    state.decisionBuffer = "";
    state.currentContext = constants_1.TokenizerContextTypes.AttributeValueBare;
    state.caretPosition++;
}
function parseTagEnd(state) {
    state.accumulatedContent = "";
    state.decisionBuffer = "";
    state.currentContext = constants_1.TokenizerContextTypes.Attributes;
}
