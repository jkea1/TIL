"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
const constants_1 = require("../../constants");
const utils_1 = require("../../utils");
const tokensMap = {
    script: constants_1.TokenTypes.OpenScriptTagEnd,
    style: constants_1.TokenTypes.OpenStyleTagEnd,
    default: constants_1.TokenTypes.OpenTagEnd,
};
const contextsMap = {
    script: constants_1.TokenizerContextTypes.ScriptContent,
    style: constants_1.TokenizerContextTypes.StyleContent,
    default: constants_1.TokenizerContextTypes.Data,
};
function parse(chars, state, tokens) {
    if (chars === ">") {
        return parseClosingCornerBrace(state, tokens);
    }
    state.accumulatedContent += state.decisionBuffer;
    state.decisionBuffer = "";
    state.caretPosition++;
}
exports.parse = parse;
function parseClosingCornerBrace(state, tokens) {
    var _a;
    const position = (0, utils_1.calculateTokenPosition)(state, { keepBuffer: true });
    const tagName = (_a = state.contextParams[constants_1.TokenizerContextTypes.OpenTagEnd]) === null || _a === void 0 ? void 0 : _a.tagName;
    tokens.push({
        type: tokensMap[tagName] || tokensMap.default,
        value: state.accumulatedContent + state.decisionBuffer,
        range: position.range,
        loc: position.loc,
    });
    state.accumulatedContent = "";
    state.decisionBuffer = "";
    state.currentContext =
        contextsMap[tagName || "default"] || contextsMap["default"];
    state.caretPosition++;
    state.contextParams[constants_1.TokenizerContextTypes.OpenTagEnd] = undefined;
}
